<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <style>
    html, body { 
      margin: 0; 
      padding: 0; 
      background: transparent; 
      overflow: hidden;
      width: 128px;
      height: 128px;
    }
    
    #pet {
      position: absolute;
      width: 100px;
      height: 100px;
      top: 14px;
      left: 14px;
      transition: transform 0.1s ease-out;
    }
    
    #pet-sprite {
      width: 100%;
      height: 100%;
      object-fit: contain;
      image-rendering: pixelated;
      pointer-events: none; /* é˜²æ­¢åœ–ç‰‡è¢«æ‹–æ‹½ */
      user-select: none; /* é˜²æ­¢é¸å– */
      -webkit-user-drag: none; /* é˜²æ­¢æ‹–æ‹½ */
    }
    
    .bounce {
      transform: scale(1.2) !important;
    }
  </style>
</head>
<body>
  <div id="pet">
    <img id="pet-sprite" src="" alt="æ¡Œå¯µ" />
  </div>
  
  <script>
    // PNG/SVG åœ–æª”é…ç½® - ç›®å‰ä½¿ç”¨SVGï¼Œä½†æ”¯æ´PNG
    const sprites = {
      idle: ['sprites/idle_1.svg', 'sprites/idle_2.svg'],
      walk: ['sprites/walk_1.svg', 'sprites/walk_1.svg'],
      bounce: ['sprites/bounce_1.svg'],
      sleep: ['sprites/idle_2.svg']
    };
    
    // å¦‚æœæœ‰PNGæª”æ¡ˆï¼Œæœƒå„ªå…ˆä½¿ç”¨PNG
    const pngSprites = {
      idle: ['sprites/idle_1.png', 'sprites/idle_2.png'],
      walk: ['sprites/walk_1.png', 'sprites/walk_1.png'],
      bounce: ['sprites/bounce_1.png'],
      sleep: ['sprites/idle_2.png']
    };
    
    // æœ€çµ‚å‚™ç”¨ - å…§å»ºSVG
    const defaultSprite = 'data:image/svg+xml;base64,' + btoa(`
      <svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
        <circle cx="50" cy="50" r="40" fill="#ff6b6b" stroke="#fff" stroke-width="3"/>
        <circle cx="38" cy="40" r="6" fill="white"/>
        <circle cx="62" cy="40" r="6" fill="white"/>
        <circle cx="38" cy="40" r="3" fill="black"/>
        <circle cx="62" cy="40" r="3" fill="black"/>
        <path d="M 35 60 Q 50 70 65 60" stroke="#fff" stroke-width="2" fill="none"/>
      </svg>
    `);
    
    let currentState = 'walk';
    let animationFrame = 0;
    let lastFrameTime = Date.now();
    const petSprite = document.getElementById('pet-sprite');
    const petElement = document.getElementById('pet');
    
    // ç§»å‹•é‚è¼¯ï¼ˆåŸºæ–¼æˆåŠŸçš„ç°¡å–®ç‰ˆæœ¬ï¼‰
    let x = 100, y = 100;
    let vx = 3, vy = 2;
    let dragging = false;
    let lastInteractionTime = Date.now();
    let isPaused = false; // æ°¸ä¹…æš«åœç‹€æ…‹ï¼ˆéœ€æ‰‹å‹•æ¢å¾©ï¼‰
    let isTemporaryPaused = false; // æš«æ™‚åœæ­¢ç‹€æ…‹ï¼ˆå³éµå¯æ¢å¾©ï¼‰
    
    function loadSprite(spritePath, fallbackPath, finalFallback) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve(spritePath);
        img.onerror = () => {
          if (fallbackPath) {
            const fallbackImg = new Image();
            fallbackImg.onload = () => resolve(fallbackPath);
            fallbackImg.onerror = () => resolve(finalFallback);
            fallbackImg.src = fallbackPath;
          } else {
            resolve(finalFallback);
          }
        };
        img.src = spritePath;
      });
    }
    
    async function updateSprite() {
      const stateSprites = sprites[currentState] || sprites.idle;
      const pngStateSprites = pngSprites[currentState] || pngSprites.idle;
      
      const spriteIndex = animationFrame % stateSprites.length;
      const svgSprite = stateSprites[spriteIndex];
      const pngSprite = pngStateSprites[spriteIndex];
      
      // å…ˆå˜—è©¦è¼‰å…¥PNGï¼Œå¦‚æœå¤±æ•—å‰‡ä½¿ç”¨SVG
      const finalSprite = await loadSprite(pngSprite, svgSprite, defaultSprite);
      petSprite.src = finalSprite;
    }
    
    function setPetState(newState) {
      currentState = newState;
      animationFrame = 0;
      updateSprite();
    }
    
    function animateFrames() {
      const now = Date.now();
      if (now - lastFrameTime > 400) { // æ¯400msåˆ‡æ›ä¸€å¹€
        animationFrame++;
        lastFrameTime = now;
        updateSprite();
      }
    }
    
    function move() {
      if (dragging || isPaused || isTemporaryPaused) return; // æ‹–æ‹½æˆ–ä»»ä½•æš«åœç‹€æ…‹æ™‚ä¸ç§»å‹•
      
      x += vx;
      y += vy;
      
      let bounced = false;
      // ç°¡å–®çš„é‚Šç•Œæª¢æ¸¬
      if (x < 0 || x > 1200) { 
        vx = -vx; 
        bounced = true; 
      }
      if (y < 0 || y > 800) { 
        vy = -vy; 
        bounced = true; 
      }
      
      // ä½¿ç”¨electronAPIç§»å‹•è¦–çª—
      if (window.electronAPI) {
        window.electronAPI.moveWindow(x, y);
      }
      
      if (bounced) {
        petElement.classList.add('bounce');
        setPetState('bounce');
        setTimeout(() => {
          petElement.classList.remove('bounce');
          setPetState('walk');
        }, 300);
      }
    }
    
    // æ»‘é¼ äº’å‹•è®Šæ•¸
    let mouseStartX, mouseStartY;
    let isMouseOver = false;
    
    // æ»‘é¼ äº’å‹•
    petElement.addEventListener('mouseenter', () => {
      console.log('Mouse enter pet');
      isMouseOver = true;
      if (window.electronAPI) {
        window.electronAPI.setMouseThrough(false);
      }
      lastInteractionTime = Date.now();
    });

    petElement.addEventListener('mouseleave', () => {
      console.log('Mouse leave pet');
      isMouseOver = false;
      // åªæœ‰åœ¨ä¸æ‹–æ‹½æ™‚æ‰å•Ÿç”¨ç©¿é€
      if (!dragging && window.electronAPI) {
        window.electronAPI.setMouseThrough(true);
        setPetState('walk');
      }
    });

    // æ‹–æ‹½é–‹å§‹äº‹ä»¶ - ç«‹å³éŸ¿æ‡‰
    petElement.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();

      // check for left click
      if (e.button === 0) {
        console.log('Mouse down - starting drag');
        
        // ç«‹å³è¨­ç½®æ‹–æ‹½ç‹€æ…‹
        dragging = true;
        window.lastDragStart = Date.now();
        mouseStartX = e.clientX;
        mouseStartY = e.clientY;
        setPetState('idle');
        
        // ç«‹å³ç¦ç”¨æ»‘é¼ ç©¿é€
        if (window.electronAPI) {
          window.electronAPI.setMouseThrough(false);
        }
      }

      // check for right click
      if (e.button === 2) {
        // å³éµé»æ“Šä¸ç›´æ¥é–‹å•Ÿå°è©±æ¡†ï¼Œç”± contextmenu äº‹ä»¶è™•ç†
        return;
      }
    });    // é˜²æ­¢åœ–ç‰‡æ‹–æ‹½
    petSprite.addEventListener('dragstart', (e) => {
      e.preventDefault();
      return false;
    });
    
    petSprite.addEventListener('selectstart', (e) => {
      e.preventDefault();
      return false;
    });
    
    // ç¯€æµçš„æ‹–æ‹½ç§»å‹•è™•ç†
    let moveTimeout = null;
    window.addEventListener('mousemove', (e) => {
      if (dragging && mouseStartX !== undefined && mouseStartY !== undefined) {
        const deltaX = e.clientX - mouseStartX;
        const deltaY = e.clientY - mouseStartY;
        
        // ç«‹å³æ›´æ–°ä½ç½®è®Šæ•¸
        x += deltaX;
        y += deltaY;
        mouseStartX = e.clientX;
        mouseStartY = e.clientY;
        
        // ç¯€æµè¦–çª—ç§»å‹•è«‹æ±‚
        if (moveTimeout) {
          clearTimeout(moveTimeout);
        }
        
        moveTimeout = setTimeout(() => {
          if (window.electronAPI) {
            window.electronAPI.moveWindow(x, y);
          }
          moveTimeout = null;
        }, 8); // 8ms ç¯€æµï¼Œç´„ 120fps
      }
    });

    // å¿«é€ŸéŸ¿æ‡‰çš„ mouseup è™•ç†
    window.addEventListener('mouseup', (e) => {
      if (e.button === 2) {
        return; // å³éµä¸è™•ç†
      }
      
      if (dragging) {
        console.log('Mouse up - ending drag');
        
        // ç«‹å³é‡ç½®æ‹–æ‹½ç‹€æ…‹
        dragging = false;
        mouseStartX = undefined;
        mouseStartY = undefined;
        setPetState('walk');
        
        // æ ¹æ“šæ»‘é¼ ä½ç½®æ±ºå®šç©¿é€ç‹€æ…‹
        if (window.electronAPI) {
          if (isMouseOver) {
            // æ»‘é¼ é‚„åœ¨å¯µç‰©ä¸Šï¼Œä¿æŒå¯äº’å‹•
            window.electronAPI.setMouseThrough(false);
          } else {
            // æ»‘é¼ ä¸åœ¨å¯µç‰©ä¸Šï¼Œå•Ÿç”¨ç©¿é€
            window.electronAPI.setMouseThrough(true);
          }
        }
      }
    });

    // åŒæ™‚ç›£è½ petElement çš„ mouseupï¼Œç¢ºä¿å¿«é€Ÿé»æ“Šè¢«æ•ç²
    petElement.addEventListener('mouseup', (e) => {
      if (dragging) {
        console.log('Pet mouseup - ending drag');
        
        // ç«‹å³é‡ç½®æ‹–æ‹½ç‹€æ…‹
        dragging = false;
        mouseStartX = undefined;
        mouseStartY = undefined;
        setPetState('walk');
        
        // æ»‘é¼ åœ¨å¯µç‰©ä¸Šï¼Œä¿æŒå¯äº’å‹•
        if (window.electronAPI) {
          window.electronAPI.setMouseThrough(false);
        }
      }
    });

    // è¦–çª—ç„¦é»è™•ç†
    window.addEventListener('blur', () => {
      if (dragging) {
        dragging = false;
        mouseStartX = undefined;
        mouseStartY = undefined;
        if (window.electronAPI) {
          window.electronAPI.setMouseThrough(true);
        }
        setPetState('walk');
      }
    });

    // ç°¡å–®çš„æ‹–æ‹½è¶…æ™‚ä¿è­·
    setInterval(() => {
      if (dragging && window.lastDragStart && (Date.now() - window.lastDragStart > 10000)) {
        dragging = false;
        mouseStartX = undefined;
        mouseStartY = undefined;
        if (window.electronAPI) {
          window.electronAPI.setMouseThrough(true);
        }
        setPetState('walk');
      }
    }, 5000);

    // æ–°å¢ï¼šå…¨åŸŸæ»‘é¼ ç›£è½ï¼Œé˜²æ­¢æ»‘é¼ äº‹ä»¶ä¸Ÿå¤±
    document.addEventListener('mouseenter', () => {
      console.log('Document mouse enter');
    });
    
    document.addEventListener('mouseleave', () => {
      console.log('Document mouse leave');
      // å¦‚æœæ»‘é¼ å®Œå…¨é›¢é–‹è¦–çª—å€åŸŸï¼Œç¢ºä¿ç©¿é€ç‹€æ…‹æ­£ç¢º
      if (!dragging && window.electronAPI) {
        setTimeout(() => {
          if (!dragging) {
            window.electronAPI.setMouseThrough(true);
          }
        }, 100);
      }
    });
    
    petElement.addEventListener('dblclick', () => {
      if (window.electronAPI) {
        window.electronAPI.toggleChat();
      }
      setPetState('bounce');
      setTimeout(() => setPetState('walk'), 500);
    });
    
    // å³éµäº‹ä»¶è™•ç† - ä½¿ç”¨åŸç”Ÿé¸å–®
    petElement.addEventListener('contextmenu', (e) => {
      e.preventDefault(); // é˜²æ­¢é¡¯ç¤ºé è¨­å³éµèœå–®
      
      // æª¢æŸ¥ç•¶å‰ç‹€æ…‹
      if (isTemporaryPaused) {
        // å¦‚æœæ˜¯æš«æ™‚åœæ­¢ç‹€æ…‹ï¼Œå³éµé»æ“Šç›´æ¥æ¢å¾©ç§»å‹•
        isTemporaryPaused = false;
        setPetState('walk');
        console.log('å³éµæ¢å¾©ç§»å‹•');
        return;
      }
      
      // æ­£å¸¸ç§»å‹•ç‹€æ…‹ - ç«‹å³åœæ­¢ä¸¦é¡¯ç¤ºåŸç”Ÿé¸å–®
      isTemporaryPaused = true;
      setPetState('idle');
      if (window.electronAPI) {
        window.electronAPI.moveWindow(x, y);
        // é¡¯ç¤ºåŸç”Ÿå³éµé¸å–®
        window.electronAPI.showContextMenu();
      }
      
      console.log('å³éµæš«åœï¼Œæ¡Œå¯µåœåœ¨ä½ç½®:', x, y);
    });
    
    // å•Ÿå‹•
    setTimeout(() => {
      if (window.electronAPI) {
        console.log('Starting PNG pet...');
        console.log('ğŸ”¥ å°æç¤ºï¼šå¦‚æœæ‹–æ‹½å¤±æ•ˆï¼ŒæŒ‰ Esc éµé‡æ–°å•Ÿå‹•æ¡Œå¯µç„¦é»ï¼');
        setPetState('walk');
        setInterval(move, 50); // ç§»å‹•æ›´æ–°
        setInterval(animateFrames, 100); // å‹•ç•«æ›´æ–°
        
        // åˆå§‹åŒ–æ»‘é¼ ç©¿é€ç‹€æ…‹
        window.electronAPI.setMouseThrough(true);
        
        // ç›£è½ä¸»é€²ç¨‹çš„æ‹–æ‹½é‡ç½®è¨Šæ¯
        if (window.electronAPI.onResetDragState) {
          window.electronAPI.onResetDragState(() => {
            console.log('Received reset drag state command from main process');
            if (dragging) {
              dragging = false;
              setPetState('walk');
            }
          });
        }
        
        // ç›£è½ä¸»é€²ç¨‹çš„é¸å–®æ“ä½œè¨Šæ¯
        if (window.electronAPI.onPetBounce) {
          window.electronAPI.onPetBounce(() => {
            setPetState('bounce');
            setTimeout(() => setPetState('walk'), 500);
          });
        }
        
        if (window.electronAPI.onSetTemporaryPause) {
          window.electronAPI.onSetTemporaryPause(() => {
            isTemporaryPaused = true;
            setPetState('idle');
            console.log('å·²è¨­ç½®è‡¨æ™‚æš«åœæ¨¡å¼');
          });
        }
        
        if (window.electronAPI.onTogglePermanentPause) {
          window.electronAPI.onTogglePermanentPause((event, pauseState) => {
            isPaused = pauseState;
            isTemporaryPaused = false;
            if (pauseState) {
              setPetState('idle');
              console.log('æ¡Œå¯µå·²æš«åœ');
            } else {
              setPetState('walk');
              console.log('æ¡Œå¯µå·²æ¢å¾©ç§»å‹•');
            }
          });
        }
      } else {
        console.error('electronAPI not found');
        petSprite.src = defaultSprite;
      }
    }, 500);
  </script>
</body>
</html>