<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <style>
    html, body { 
      margin: 0; 
      padding: 0; 
      background: transparent; 
      overflow: hidden;
      width: 128px;
      height: 128px;
    }
    
    #pet {
      position: absolute;
      width: 100px;
      height: 100px;
      top: 14px;
      left: 14px;
      transition: transform 0.1s ease-out;
    }
    
    #pet-sprite {
      width: 100%;
      height: 100%;
      object-fit: contain;
      image-rendering: pixelated;
      pointer-events: none; /* 防止圖片被拖拽 */
      user-select: none; /* 防止選取 */
      -webkit-user-drag: none; /* 防止拖拽 */
    }
    
    .bounce {
      transform: scale(1.2) !important;
    }
  </style>
</head>
<body>
  <div id="pet">
    <img id="pet-sprite" src="" alt="桌寵" />
  </div>
  
  <script>
    // 手繪 PNG 圖檔配置 - 根據 README.md 說明
    const handdrawnSprites = {
      // 睡覺待機動畫：1-6 循環
      idle: [
        'sprites/idle_sleeping/idle_sleeping_1.PNG',
        'sprites/idle_sleeping/idle_sleeping_2.PNG',
        'sprites/idle_sleeping/idle_sleeping_3.PNG',
        'sprites/idle_sleeping/idle_sleeping_4.PNG',
        'sprites/idle_sleeping/idle_sleeping_5.PNG',
        'sprites/idle_sleeping/idle_sleeping_6.PNG'
      ],
      // 行走動畫：1-7 循環（面向左，可自動翻轉）
      walk: [
        'sprites/walking/walking_1.PNG',
        'sprites/walking/walking_2.PNG',
        'sprites/walking/walking_3.PNG',
        'sprites/walking/walking_4.PNG',
        'sprites/walking/walking_5.PNG',
        'sprites/walking/walking_6.PNG',
        'sprites/walking/walking_7.PNG'
      ],
      // 清醒動畫：1-8 (滑鼠點擊叫醒時使用)
      awake: [
        'sprites/awake/awake_1.PNG',
        'sprites/awake/awake_2.PNG',
        'sprites/awake/awake_3.PNG',
        'sprites/awake/awake_4.PNG',
        'sprites/awake/awake_5.PNG',
        'sprites/awake/awake_6.PNG',
        'sprites/awake/awake_7.PNG',
        'sprites/awake/awake_8.PNG'
      ],
      // 彈跳動畫（暫時使用第一幀）
      bounce: ['sprites/walking/walking_1.PNG'],
      // 睡覺動畫（使用 idle_sleeping 的第一幀）
      sleep: ['sprites/idle_sleeping/idle_sleeping_1.PNG']
    };
    
    // PNG/SVG 圖檔配置 - 目前使用SVG，但支援PNG
    const sprites = {
      idle: ['sprites/idle_1.svg', 'sprites/idle_2.svg'],
      walk: ['sprites/walk_1.svg', 'sprites/walk_1.svg'],
      bounce: ['sprites/bounce_1.svg'],
      sleep: ['sprites/idle_2.svg']
    };
    
    // 如果有PNG檔案，會優先使用PNG
    const pngSprites = {
      idle: ['sprites/idle_1.png', 'sprites/idle_2.png'],
      walk: ['sprites/walk_1.png', 'sprites/walk_1.png'],
      bounce: ['sprites/bounce_1.png'],
      sleep: ['sprites/idle_2.png']
    };
    
    // 最終備用 - 內建SVG
    const defaultSprite = 'data:image/svg+xml;base64,' + btoa(`
      <svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
        <circle cx="50" cy="50" r="40" fill="#ff6b6b" stroke="#fff" stroke-width="3"/>
        <circle cx="38" cy="40" r="6" fill="white"/>
        <circle cx="62" cy="40" r="6" fill="white"/>
        <circle cx="38" cy="40" r="3" fill="black"/>
        <circle cx="62" cy="40" r="3" fill="black"/>
        <path d="M 35 60 Q 50 70 65 60" stroke="#fff" stroke-width="2" fill="none"/>
      </svg>
    `);
    
    let currentState = 'walk';
    let animationFrame = 0;
    let lastFrameTime = Date.now();
    const petSprite = document.getElementById('pet-sprite');
    const petElement = document.getElementById('pet');
    
    // 移動邏輯（基於成功的簡單版本）
    let x = 100, y = 100;
    let vx = 3, vy = 2;
    let dragging = false;
    let lastInteractionTime = Date.now();
    let isPaused = false; // 永久暫停狀態（需手動恢復）
    let isTemporaryPaused = false; // 暫時停止狀態（右鍵可恢復）
    let isContextMenuOpen = false; // 追蹤右鍵選單是否開啟
    
    function loadSprite(...spritePaths) {
      return new Promise((resolve) => {
        function tryLoadSprite(index) {
          if (index >= spritePaths.length) {
            resolve(defaultSprite); // 如果所有路徑都失敗，使用預設
            return;
          }
          
          const img = new Image();
          img.onload = () => resolve(spritePaths[index]);
          img.onerror = () => tryLoadSprite(index + 1); // 嘗試下一個
          img.src = spritePaths[index];
        }
        
        tryLoadSprite(0);
      });
    }
    
    async function updateSprite() {
      // 優先使用手繪圖片，然後是 PNG，最後是 SVG
      const handdrawnStateSprites = handdrawnSprites[currentState] || handdrawnSprites.idle;
      const stateSprites = sprites[currentState] || sprites.idle;
      const pngStateSprites = pngSprites[currentState] || pngSprites.idle;
      
      const spriteIndex = animationFrame % handdrawnStateSprites.length;
      const handdrawnSprite = handdrawnStateSprites[spriteIndex];
      const svgSprite = stateSprites[spriteIndex % stateSprites.length];
      const pngSprite = pngStateSprites[spriteIndex % pngStateSprites.length];
      
      // 優先順序：手繪 PNG -> 一般 PNG -> SVG -> 預設
      const finalSprite = await loadSprite(handdrawnSprite, pngSprite, svgSprite);
      petSprite.src = finalSprite;
    }
    
    function setPetState(newState) {
      currentState = newState;
      animationFrame = 0;
      updateSprite();
    }
    
    function animateFrames() {
      const now = Date.now();
      if (now - lastFrameTime > 400) { // 每400ms切換一幀
        animationFrame++;
        lastFrameTime = now;
        updateSprite();
      }
    }
    
    function move() {
      if (dragging || isPaused || isTemporaryPaused || isContextMenuOpen) return; // 移除 isDesktopFocused 檢查
      
      x += vx;
      y += vy;
      
      let bounced = false;
      // 改進的邊界檢測 - 更嚴格的邊界
      if (x < 10) { 
        x = 10;
        vx = -vx; 
        bounced = true; 
      }
      if (x > 1200) { 
        x = 1200;
        vx = -vx; 
        bounced = true; 
      }
      if (y < 10) { 
        y = 10;
        vy = -vy; 
        bounced = true; 
      }
      if (y > 800) { 
        y = 800;
        vy = -vy; 
        bounced = true; 
      }
      
      // 使用electronAPI移動視窗
      if (window.electronAPI) {
        window.electronAPI.moveWindow(x, y);
      }
      
      if (bounced) {
        petElement.classList.add('bounce');
        setPetState('bounce');
        setTimeout(() => {
          petElement.classList.remove('bounce');
          setPetState('walk');
        }, 300);
      }
    }
    
    // 滑鼠互動變數
    let mouseStartX, mouseStartY;
    let isMouseOver = false;
    
    // 滑鼠互動處理函數
    function handleMouseEnter() {
      console.log('=== Mouse enter pet ===');
      console.log('設置滑鼠穿透: false');
      isMouseOver = true;
      if (window.electronAPI) {
        window.electronAPI.setMouseThrough(false);
      }
      lastInteractionTime = Date.now();
    }

    function handleMouseLeave() {
      console.log('=== Mouse leave pet ===');
      console.log('dragging:', dragging);
      console.log('isContextMenuOpen:', isContextMenuOpen);
      console.log('準備設置滑鼠穿透: true');
      isMouseOver = false;
      // 只有在不拖拽且沒有開啟右鍵選單時才啟用穿透
      if (!dragging && !isContextMenuOpen && window.electronAPI) {
        window.electronAPI.setMouseThrough(true);
        setPetState('walk');
        console.log('滑鼠穿透已設置為 true');
      } else {
        console.log('未設置滑鼠穿透，dragging:', dragging, 'isContextMenuOpen:', isContextMenuOpen);
      }
    }

    // 滑鼠互動
    petElement.addEventListener('mouseenter', handleMouseEnter);
    petElement.addEventListener('mouseleave', handleMouseLeave);

    // 拖拽開始事件 - 立即響應
    petElement.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();

      // check for left click
      if (e.button === 0) {
        console.log('Mouse down - starting drag');
        
        // 立即設置拖拽狀態
        dragging = true;
        window.lastDragStart = Date.now();
        mouseStartX = e.clientX;
        mouseStartY = e.clientY;
        setPetState('idle');
        
        // 立即禁用滑鼠穿透
        if (window.electronAPI) {
          window.electronAPI.setMouseThrough(false);
        }
      }

      // check for right click
      if (e.button === 2) {
        // 右鍵點擊不直接開啟對話框，由 contextmenu 事件處理
        return;
      }
    });    // 防止圖片拖拽
    petSprite.addEventListener('dragstart', (e) => {
      e.preventDefault();
      return false;
    });
    
    petSprite.addEventListener('selectstart', (e) => {
      e.preventDefault();
      return false;
    });
    
    // 節流的拖拽移動處理
    let moveTimeout = null;
    window.addEventListener('mousemove', (e) => {
      if (dragging && mouseStartX !== undefined && mouseStartY !== undefined) {
        const deltaX = e.clientX - mouseStartX;
        const deltaY = e.clientY - mouseStartY;
        
        // 立即更新位置變數
        x += deltaX;
        y += deltaY;
        mouseStartX = e.clientX;
        mouseStartY = e.clientY;
        
        // 節流視窗移動請求
        if (moveTimeout) {
          clearTimeout(moveTimeout);
        }
        
        moveTimeout = setTimeout(() => {
          if (window.electronAPI) {
            window.electronAPI.moveWindow(x, y);
          }
          moveTimeout = null;
        }, 8); // 8ms 節流，約 120fps
      }
    });

    // 快速響應的 mouseup 處理
    window.addEventListener('mouseup', (e) => {
      if (e.button === 2) {
        return; // 右鍵不處理
      }
      
      if (dragging) {
        console.log('Mouse up - ending drag');
        
        // 立即重置拖拽狀態
        dragging = false;
        mouseStartX = undefined;
        mouseStartY = undefined;
        setPetState('walk');
        
        // 根據滑鼠位置決定穿透狀態
        if (window.electronAPI) {
          if (isMouseOver) {
            // 滑鼠還在寵物上，保持可互動
            window.electronAPI.setMouseThrough(false);
          } else {
            // 滑鼠不在寵物上，啟用穿透
            window.electronAPI.setMouseThrough(true);
          }
        }
      }
    });

    // 同時監聽 petElement 的 mouseup，確保快速點擊被捕獲
    petElement.addEventListener('mouseup', (e) => {
      if (dragging) {
        console.log('Pet mouseup - ending drag');
        
        // 立即重置拖拽狀態
        dragging = false;
        mouseStartX = undefined;
        mouseStartY = undefined;
        setPetState('walk');
        
        // 滑鼠在寵物上，保持可互動
        if (window.electronAPI) {
          window.electronAPI.setMouseThrough(false);
        }
      }
    });

    // 視窗焦點處理
    window.addEventListener('blur', () => {
      if (dragging) {
        dragging = false;
        mouseStartX = undefined;
        mouseStartY = undefined;
        if (window.electronAPI) {
          window.electronAPI.setMouseThrough(true);
        }
        setPetState('walk');
      }
    });

    // 簡單的拖拽超時保護
    setInterval(() => {
      if (dragging && window.lastDragStart && (Date.now() - window.lastDragStart > 10000)) {
        dragging = false;
        mouseStartX = undefined;
        mouseStartY = undefined;
        if (window.electronAPI) {
          window.electronAPI.setMouseThrough(true);
        }
        setPetState('walk');
      }
    }, 5000);

    // 新增：全域滑鼠監聽，防止滑鼠事件丟失
    document.addEventListener('mouseenter', () => {
      console.log('Document mouse enter');
    });
    
    document.addEventListener('mouseleave', () => {
      console.log('Document mouse leave');
      // 如果滑鼠完全離開視窗區域，確保穿透狀態正確
      if (!dragging && window.electronAPI) {
        setTimeout(() => {
          if (!dragging) {
            window.electronAPI.setMouseThrough(true);
          }
        }, 100);
      }
    });
    
    // 右鍵事件處理函數
    function handleContextMenu(e) {
      console.log('=== 右鍵事件觸發 ===');
      console.log('事件對象:', e);
      console.log('當前時間:', new Date().toLocaleTimeString());
      console.log('isContextMenuOpen:', isContextMenuOpen);
      console.log('isMouseOver:', isMouseOver);
      console.log('dragging:', dragging);
      
      e.preventDefault(); // 防止顯示預設右鍵菜單
      e.stopPropagation(); // 阻止事件冒泡
      
      console.log('右鍵點擊，當前選單狀態:', isContextMenuOpen);
      
      // 如果選單已經開啟，先關閉它
      if (isContextMenuOpen) {
        console.log('選單已開啟，重置狀態');
        isContextMenuOpen = false;
      }
      
      // 右鍵時暫停移動
      isContextMenuOpen = true;
      setPetState('idle');
      
      // 直接顯示原生選單
      if (window.electronAPI) {
        window.electronAPI.showContextMenu();
      }
      
      console.log('顯示右鍵選單，桌寵暫停移動');
    }

    // 綁定右鍵事件處理 - 使用原生選單
    petElement.addEventListener('contextmenu', handleContextMenu);
    
    // 啟動
    setTimeout(() => {
      if (window.electronAPI) {
        console.log('Starting PNG pet...');
        console.log('🔥 小提示：如果拖拽失效，按 Esc 鍵重新啟動桌寵焦點！');
        setPetState('walk');
        setInterval(move, 50); // 移動更新
        setInterval(animateFrames, 100); // 動畫更新
        
        // 實際重置選單狀態的函數
        function resetContextMenu() {
          console.log('安全檢查：選單狀態可能異常，已自動重置');
          isContextMenuOpen = false;
          if (typeof closeContextMenu === 'function') {
            closeContextMenu();
          }
        }
        
        setInterval(() => {
          // 如果選單開啟超過 10 秒，可能有問題，自動重置
          if (isContextMenuOpen) {
            resetContextMenu();
          }
        }, 10000);
        
        // 初始化滑鼠穿透狀態
        window.electronAPI.setMouseThrough(true);
        
        // 監聽主進程的拖拽重置訊息
        if (window.electronAPI.onResetDragState) {
          window.electronAPI.onResetDragState(() => {
            console.log('Received reset drag state command from main process');
            if (dragging) {
              dragging = false;
              setPetState('walk');
            }
          });
        }
        
        // 監聽主進程的選單操作訊息
        if (window.electronAPI.onPetBounce) {
          window.electronAPI.onPetBounce(() => {
            setPetState('bounce');
            setTimeout(() => setPetState('walk'), 500);
          });
        }
        
        if (window.electronAPI.onTogglePermanentPause) {
          window.electronAPI.onTogglePermanentPause((event, pauseState) => {
            isPaused = pauseState;
            isTemporaryPaused = false;
            if (pauseState) {
              setPetState('idle');
              console.log('桌寵已暫停');
            } else {
              setPetState('walk');
              console.log('桌寵已恢復移動');
            }
          });
        }
        
        // 監聽焦點切換事件
        if (window.electronAPI.onFocusChanged) {
          window.electronAPI.onFocusChanged((event, appName) => {
            console.log('應用焦點切換到:', appName);
            // 焦點切換時的處理可以在這裡添加
          });
        }
        
        if (window.electronAPI.onDesktopFocused) {
          window.electronAPI.onDesktopFocused(() => {
            console.log('桌面獲得焦點 - 桌寵保持原狀態');
            // 不改變移動狀態，只記錄焦點狀態
          });
        }
        
        // 監聽視窗重新獲得焦點
        window.addEventListener('focus', () => {
          console.log('桌寵視窗重新獲得焦點');
          // 安全重置：如果選單狀態異常，重置它
          if (isContextMenuOpen) {
            console.log('安全重置：重置選單狀態');
            isContextMenuOpen = false;
          }
          // 不需要特別處理，桌寵會根據原本的狀態繼續運作
        });
        
        // 監聽右鍵選單關閉事件
        if (window.electronAPI.onContextMenuClosed) {
          window.electronAPI.onContextMenuClosed(() => {
            console.log('=== 右鍵選單已關閉 ===');
            console.log('關閉前 isContextMenuOpen:', isContextMenuOpen);
            console.log('isMouseOver:', isMouseOver);
            isContextMenuOpen = false;
            
            // 完全重新初始化整個事件系統
            console.log('完全重新初始化事件系統');
            
            // 移除所有滑鼠事件監聽器
            petElement.removeEventListener('contextmenu', handleContextMenu);
            petElement.removeEventListener('mouseenter', handleMouseEnter);
            petElement.removeEventListener('mouseleave', handleMouseLeave);
            
            // 強制重置所有狀態
            isMouseOver = false;
            dragging = false;
            
            // 強制重置滑鼠狀態
            if (window.electronAPI.forceResetMouseState) {
              console.log('執行強制重置滑鼠狀態');
              window.electronAPI.forceResetMouseState();
            }
            
            // 延遲重新綁定所有事件監聽器
            setTimeout(() => {
              console.log('重新綁定所有事件監聽器');
              petElement.addEventListener('contextmenu', handleContextMenu);
              petElement.addEventListener('mouseenter', handleMouseEnter);
              petElement.addEventListener('mouseleave', handleMouseLeave);
              
              // 模擬 mouseenter 重置狀態
              console.log('模擬 mouseenter 重置狀態');
              handleMouseEnter();
            }, 100);
            
            // 如果沒有其他暫停狀態，恢復移動（不考慮桌面焦點）
            if (!isPaused && !isTemporaryPaused) {
              console.log('恢復桌寵移動');
              setPetState('walk');
            } else {
              console.log('不恢復移動，isPaused:', isPaused, 'isTemporaryPaused:', isTemporaryPaused);
            }
          });
        }
      } else {
        console.error('electronAPI not found');
        petSprite.src = defaultSprite;
      }
    }, 500);
  </script>
</body>
</html>