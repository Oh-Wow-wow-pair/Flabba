
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <style>
    html, body { margin:0; padding:0; background:transparent; overflow:hidden; }
    canvas { display:block; }
    #hit { position:fixed; inset:0; }
  </style>
</head>
<body>
  <div id="hit"></div>
  <script type="module">
    // three.js via CDN for quick MVP
    import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';

    const { electronAPI } = window;

    // Scene
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setClearColor(0x000000, 0); // fully transparent
    renderer.setSize(256, 256);
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(0, 0.6, 2);

    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(1,2,3);
    scene.add(dir);

    // Pet mesh (cute sphere placeholder)
    const pet = new THREE.Mesh(
      new THREE.SphereGeometry(0.4, 32, 32),
      new THREE.MeshStandardMaterial({ color: 0x50a0ff, metalness: 0.2, roughness: 0.4 })
    );
    scene.add(pet);

    // Eyes
    const eyeGeo = new THREE.SphereGeometry(0.05, 16, 16);
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
    const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
    eyeL.position.set(-0.12, 0.08, 0.38);
    eyeR.position.set( 0.12, 0.08, 0.38);
    scene.add(eyeL, eyeR);

    // Idle animation
    let t = 0;
    function animate() {
      t += 0.02;
      pet.rotation.y += 0.01;
      pet.position.y = Math.sin(t) * 0.03;
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // Window move/bounce logic
    const WIN = { w: 256, h: 256 };
    let vx = 1.8, vy = 1.4;
    let x = 100, y = 100;
    let dragging = false, offX = 0, offY = 0;
    let bounds = { xMin: 0, yMin: 0, xMax: 1200, yMax: 800 };

    electronAPI.getDisplays().then(info => {
      const primary = info.displays.find(d => d.id === info.primary) || info.displays[0];
      const wa = primary.workArea;
      bounds = { xMin: wa.x, yMin: wa.y, xMax: wa.x + wa.width - WIN.w, yMax: wa.y + wa.height - WIN.h };
    }).catch(()=>{});

    function stepMove() {
      if (!dragging) {
        x += vx; y += vy;
        if (x <= bounds.xMin || x >= bounds.xMax) vx *= -1;
        if (y <= bounds.yMin || y >= bounds.yMax) vy *= -1;
        x = Math.max(bounds.xMin, Math.min(bounds.xMax, x));
        y = Math.max(bounds.yMin, Math.min(bounds.yMax, y));
        electronAPI.moveWindow(x, y);
      }
      requestAnimationFrame(stepMove);
    }
    stepMove();

    // Mouse interactions
    const hit = document.getElementById('hit');
    hit.addEventListener('mouseenter', () => electronAPI.setMouseThrough(false));
    hit.addEventListener('mouseleave', () => { if (!dragging) electronAPI.setMouseThrough(true); });
    hit.addEventListener('mousedown', (e) => { dragging = true; offX = e.clientX; offY = e.clientY; });
    window.addEventListener('mouseup', () => { dragging = false; electronAPI.setMouseThrough(true); });
    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      x += (e.clientX - offX);
      y += (e.clientY - offY);
      offX = e.clientX; offY = e.clientY;
      x = Math.max(bounds.xMin, Math.min(bounds.xMax, x));
      y = Math.max(bounds.yMin, Math.min(bounds.yMax, y));
      electronAPI.moveWindow(x, y);
    });
    hit.addEventListener('dblclick', () => electronAPI.toggleChat());
  </script>
</body>
</html>
