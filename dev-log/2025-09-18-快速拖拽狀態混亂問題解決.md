# 快速拖拽導致滑鼠監測狀態混亂問題解決記錄

## 問題描述

在桌寵開發過程中，發現當用戶進行快速拖拽操作（迅速按下、移動、然後放開滑鼠）時，會導致滑鼠事件狀態混亂，具體表現為：

1. 桌寵無法正確偵測滑鼠是否在附近
2. 滑鼠穿透狀態（setIgnoreMouseEvents）切換異常
3. 拖拽狀態（dragging）可能卡在 true，導致後續互動失效
4. 視窗焦點管理混亂

## 原始實作方式的問題

### 1. 事件處理有延遲和異步問題

原始程式碼：
```javascript
// 主程序 - 有 50ms 延遲
ipcMain.handle('toggle-mouse-through', (_e, ignore) => {
  if (petWindow) {
    if (ignore) {
      petWindow.focus();
      setTimeout(() => {  // 問題：50ms 延遲
        petWindow.setIgnoreMouseEvents(true, { forward: true });
      }, 50);
    } else {
      petWindow.setIgnoreMouseEvents(false);
      petWindow.focus();
    }
  }
});

// 前端 - 簡單的事件處理
petElement.addEventListener('mousedown', (e) => {
  dragging = true;
  // 設置狀態...
  window.electronAPI.setMouseThrough(false);  // 問題：可能被快速操作打斷
});
```

問題分析：
- 滑鼠穿透狀態切換有 50ms 延遲，快速操作時狀態會不同步
- 沒有考慮到 mouseup 事件可能在 mousedown 延遲處理完成前就觸發
- 單一的 mouseup 監聽器無法捕獲所有快速點擊事件

### 2. 狀態管理不完整

原始程式碼：
```javascript
window.addEventListener('mouseup', () => {
  if (dragging) {
    dragging = false;
    window.electronAPI.setMouseThrough(true);  // 問題：總是啟用穿透
    setPetState('walk');
  }
});
```

問題分析：
- 沒有追蹤滑鼠是否還在寵物範圍內
- mouseup 後總是啟用穿透，即使滑鼠還在寵物上
- 缺少 isMouseOver 狀態追蹤

### 3. 無限循環和過度日誌

原始程式碼：
```javascript
// 問題：無限觸發的焦點事件
app.on('browser-window-focus', (event, window) => {
  if (window === petWindow) {
    console.log('Pet window regained focus');  // 會無限輸出
    setTimeout(() => {
      if (petWindow) {
        petWindow.setIgnoreMouseEvents(true, { forward: true });
      }
    }, 500);
  }
});

// 問題：過於頻繁的狀態檢查
setInterval(() => {
  // 每 1 秒檢查拖拽狀態
  if (dragging && window.lastDragStart && (Date.now() - window.lastDragStart > 10000)) {
    // 重置邏輯...
  }
}, 1000);
```

問題分析：
- browser-window-focus 事件會無限觸發，造成性能問題
- 定期檢查機制過於頻繁，影響系統資源

## 解決方案實作

### 1. 立即響應的事件處理

新的實作：
```javascript
// 主程序 - 移除延遲，立即響應
ipcMain.handle('toggle-mouse-through', (_e, ignore) => {
  if (petWindow) {
    if (ignore) {
      // 改進：立即設置，不等待
      petWindow.setIgnoreMouseEvents(true, { forward: true });
    } else {
      // 改進：立即設置
      petWindow.setIgnoreMouseEvents(false);
      petWindow.focus();
    }
  }
});

// 前端 - 立即狀態更新
petElement.addEventListener('mousedown', (e) => {
  e.preventDefault();
  e.stopPropagation();
  
  // 改進：立即設置拖拽狀態
  dragging = true;
  window.lastDragStart = Date.now();
  mouseStartX = e.clientX;
  mouseStartY = e.clientY;
  setPetState('idle');
  
  // 改進：立即禁用滑鼠穿透
  if (window.electronAPI) {
    window.electronAPI.setMouseThrough(false);
  }
});
```

改進效果：
- 消除了 50ms 延遲，讓狀態切換即時響應
- 快速拖拽不會因為延遲導致狀態不同步

### 2. 智能狀態管理

新的實作：
```javascript
// 改進：新增滑鼠位置狀態追蹤
let isMouseOver = false;

petElement.addEventListener('mouseenter', () => {
  isMouseOver = true;  // 追蹤滑鼠進入
  if (window.electronAPI) {
    window.electronAPI.setMouseThrough(false);
  }
});

petElement.addEventListener('mouseleave', () => {
  isMouseOver = false;  // 追蹤滑鼠離開
  if (!dragging && window.electronAPI) {
    window.electronAPI.setMouseThrough(true);
  }
});

// 改進：智能的 mouseup 處理
window.addEventListener('mouseup', (e) => {
  if (dragging) {
    dragging = false;
    mouseStartX = undefined;
    mouseStartY = undefined;
    setPetState('walk');
    
    // 根據滑鼠位置決定穿透狀態
    if (window.electronAPI) {
      if (isMouseOver) {
        // 滑鼠還在寵物上，保持可互動
        window.electronAPI.setMouseThrough(false);
      } else {
        // 滑鼠不在寵物上，啟用穿透
        window.electronAPI.setMouseThrough(true);
      }
    }
  }
});
```

改進效果：
- 精確追蹤滑鼠是否在寵物範圍內
- mouseup 後根據實際滑鼠位置決定穿透狀態
- 避免了錯誤的狀態切換

### 3. 雙重事件監聽確保快速操作被捕獲

新的實作：
```javascript
// 改進：雙重 mouseup 監聽
// 全域 mouseup - 處理滑鼠移出寵物範圍的情況
window.addEventListener('mouseup', (e) => { /* ... */ });

// 寵物元素 mouseup - 確保快速點擊被捕獲
petElement.addEventListener('mouseup', (e) => {
  if (dragging) {
    dragging = false;
    mouseStartX = undefined;
    mouseStartY = undefined;
    setPetState('walk');
    
    // 滑鼠在寵物上，保持可互動
    if (window.electronAPI) {
      window.electronAPI.setMouseThrough(false);
    }
  }
});
```

改進效果：
- 確保即使是非常快速的點擊也能被正確捕獲
- 提供冗餘機制，避免事件遺漏

### 4. 節流優化避免過度 IPC 調用

新的實作：
```javascript
// 改進：節流的拖拽移動處理
let moveTimeout = null;
window.addEventListener('mousemove', (e) => {
  if (dragging && mouseStartX !== undefined && mouseStartY !== undefined) {
    const deltaX = e.clientX - mouseStartX;
    const deltaY = e.clientY - mouseStartY;
    
    // 立即更新位置變數
    x += deltaX;
    y += deltaY;
    mouseStartX = e.clientX;
    mouseStartY = e.clientY;
    
    // 節流視窗移動請求
    if (moveTimeout) {
      clearTimeout(moveTimeout);
    }
    
    moveTimeout = setTimeout(() => {
      if (window.electronAPI) {
        window.electronAPI.moveWindow(x, y);
      }
      moveTimeout = null;
    }, 8); // 8ms 節流，約 120fps
  }
});
```

改進效果：
- 減少過度的 IPC 調用，提升性能
- 保持流暢的拖拽體驗（120fps）
- 避免因為過多的 IPC 調用導致的事件堆積

### 5. 清理無限循環和過度日誌

移除的問題程式碼：
```javascript
// 移除：會無限觸發的焦點事件監聽器
app.on('browser-window-focus', (event, window) => {
  // 這段程式碼被完全移除
});

// 移除：過度的定期檢查
setInterval(() => {
  // 移除了會造成性能問題的定期檢查
}, 5000);
```

改進效果：
- 消除了無限輸出的日誌
- 減少了不必要的系統資源消耗
- 提升整體應用性能

## 技術要點總結

### 1. 事件處理優化原則
- 立即響應：移除所有不必要的 setTimeout 延遲
- 狀態同步：確保前端和主程序狀態保持一致
- 事件優先級：critical 操作（如狀態切換）應該同步執行

### 2. 狀態管理最佳實踐
- 完整狀態追蹤：追蹤所有相關狀態（dragging, isMouseOver, mouseStart 座標）
- 智能狀態決策：根據多個狀態變數做出正確的行為決策
- 狀態重置保護：確保所有狀態變數在適當時機被重置

### 3. 性能優化策略
- 事件節流：對高頻事件（如 mousemove）使用適當的節流
- 冗餘監聽：關鍵事件（如 mouseup）使用多重監聽確保捕獲
- 資源清理：移除無限循環和不必要的定期檢查

## 測試結果

實施這些改進後，快速拖拽操作的問題得到了顯著改善：

1. 快速拖拽響應正常：即使是非常快速的拖拽-放開操作也能正確處理
2. 狀態一致性：滑鼠穿透狀態和拖拽狀態保持同步
3. 性能提升：消除了無限循環日誌，系統資源使用正常
4. 用戶體驗：拖拽操作流暢，沒有延遲感

## 經驗教訓

1. 微秒級的用戶操作需要微秒級的程式響應：50ms 的延遲在快速操作中是無法接受的
2. 狀態管理要考慮所有邊緣情況：不能假設事件會按照預期順序觸發
3. IPC 調用需要謹慎優化：過度的主程序-渲染程序通信會影響響應性
4. 事件監聽需要冗餘機制：單一監聽器可能無法捕獲所有快速操作

---

日誌記錄時間：2025年9月18日
問題解決狀態：已解決